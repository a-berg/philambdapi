<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>&Phi; &Lambda; &Pi; - Taichi First Steps</title>
        <link rel="stylesheet" type="text/css" href="../css/default_A.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">&Phi; &Lambda; &Pi;</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>
        <main role="main">
            <h1>Taichi First Steps</h1>
            <article>
    <section class="header">
        Posted on January 20, 2023
        
    </section>
    <section>
        <p>As I delved into the fascinating world of <a href="https://physicsbaseddeeplearning.org/diffphys.html">differentiable physics</a>, I stumbled upon a gem
of a language called Taichi. Its ability to effortlessly bring GPU programming to Python
caught my attention and I was instantly hooked.</p>
<blockquote>
<p><em>Warning: the post is a bit long!</em></p>
</blockquote>
<h2 id="the-case-for-taichi">The case for Taichi</h2>
<p>In the world of ML, Python is king. Now, Python has lot of nice things, but performance
is a known pain-point of the language since its inception. There’s been no shortage of
work-arounds and solutions to this problem, from offloading to C/Fortran (which is what
earlier solutions like <code class="verbatim">numpy</code>, <code class="verbatim">scipy</code> and <code class="verbatim">cython</code> did, but also Tensorflow and Pytorch) to
more elaborate JIT strategies (such as Numba and PyPy). In fact, there was even an
attempt to overthrow Python altogether and go in a “numeric-centric” approach: a nice
language named <a href="https://julialang.org/">Julia</a>. Now, I won’t go into this language now but let me just say that
while it has a lot of great ideas, it didn’t completely stick: the ML people love their
Python and they just won’t leave such a massive ecosystem for an unknown, albeit
promising, alternative.</p>
<p>Taichi’s creator <a href="https://github.com/yuanming-hu">Yuanming Hu</a> seemingly didn’t make that mistake and presents a new
language under the guise of a library and set of decorators (much like Tensorflow does
btw). Taichi, essentially, is a compiled language with a syntax almost entirely equal to
that of Python that lets you do automatic differentiation and GPU computation (among
other high-performance related features).</p>
<p>I must say, I am impressed with the language.</p>
<h2 id="the-julia-set">The Julia set</h2>
<p><a href="https://en.wikipedia.org/wiki/Julia_set">Julia sets</a> are a type of fractal particularly interesting for paralellization since the
computations for each point in the complex plane are independent from each other. They
are beautiful once rendered and easy to understand and implement. Taichi’s <a href="https://docs.taichi-lang.org/docs/hello_world">hello world</a>
example is exactly this, a code that I reproduce here with minimal changes.</p>
<p>Let’s recall the definition of a Julia set:</p>
<p><span class="math display">{<em>z</em>∈ℂ:∀<em>n</em>∈ℕ,|<em>f</em><sub><em>c</em></sub><sup><em>n</em></sup>(<em>z</em>)|≤<em>R</em>}</span></p>
<p>This definition essentially reads: for a complex number <span class="math inline"><em>c</em></span>, if the sequence defined
by iteratively applying the function <span class="math inline"><em>f</em><sub><em>c</em></sub>(<em>z</em>)</span> to itself converges for a given <span class="math inline"><em>z</em></span>
means that <span class="math inline"><em>z</em></span> is in the set. The funcion <span class="math inline"><em>f</em><sub><em>c</em></sub>(<em>z</em>)</span> can be any (non-constant)
holomorphic function, but the classic choice is <span class="math inline"><em>z</em><sup>2</sup> + <em>c</em></span>.</p>
<p>In practice, there’s a radius over which the sequence is known to diverge (<span class="math inline"><em>R</em> = 2</span>) and
therefore a maximum number of iterations is set: if the sequence has not diverged after
this number of iterations, then you consider it as a point of the set. For aesthetic
reasons, for those points that diverge, a color is assigned based on how many iterations
they took to diverge.</p>
<p>Now that we have a brief introduction on the problem, let’s write the program that will
compute it.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> taichi <span class="im">as</span> ti</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> taichi.math <span class="im">as</span> tm</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ti.init(arch<span class="op">=</span>ti.gpu)</span></code></pre></div>
<p>Initially, we import <code class="verbatim">taichi</code>, <code class="verbatim">taichi.math</code> and initialize the Taichi backend, telling it
to run on the GPU. Just like that, we are going to compile code for our graphics card,
no CUDA needed.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">320</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>pixels <span class="op">=</span> ti.field(dtype<span class="op">=</span><span class="bu">float</span>, shape<span class="op">=</span>(n <span class="op">*</span> <span class="dv">2</span>, n))</span></code></pre></div>
<p>Next, define a simple costant for image size (<code class="verbatim">n=320</code> means that we will compute a 640×320
image) and a taichi <code class="verbatim">field</code>, a data structure that more or less represents a nd array or a
tensor, although =field=s also have information about their layout (this means that you
can have a lot of granularity over how the data is represented in memory and seen by the
processor, allowing for advanced performance insights).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ti.func</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> complex_square(z):  <span class="co"># complex square of a 2D vector</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tm.vec2(z[<span class="dv">0</span>] <span class="op">*</span> z[<span class="dv">0</span>] <span class="op">-</span> z[<span class="dv">1</span>] <span class="op">*</span> z[<span class="dv">1</span>], <span class="dv">2</span> <span class="op">*</span> z[<span class="dv">0</span>] <span class="op">*</span> z[<span class="dv">1</span>])</span></code></pre></div>
<p>We define the operation of squaring complex numbers (here assuming they are represented
by a struct with 2 elements), as we will need it to compute the sequence. Notice a
couple of things: the <code class="verbatim">@ti.func</code> decorator, and <code class="verbatim">tm.vec2</code> (from the previous <code class="verbatim">taichi.math</code>
import).</p>
<p>By decorating a python function with <code class="verbatim">@ti.func</code> you are in fact swapping languages and
defining a Taichi function. Taichi functions are procedures to be used inside Taichi
<em>kernels</em>, (or inside other Taichi functions), and not in regular python code. In other
words: this function is no longer a python function. Another thing: Taichi functions can
be nested, but are not allowed to be called recursively. Additionally, the use of
<code class="verbatim">tm.vec2</code> reveals anoter taichi function, in particular a constructor of vectors.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ti.kernel</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paint(t: <span class="bu">float</span>):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, j <span class="kw">in</span> pixels:  <span class="co"># Parallelized over all pixels</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> tm.vec2(<span class="fl">0.7885</span> <span class="op">*</span> tm.cos(t), <span class="fl">0.7885</span> <span class="op">*</span> tm.sin(t))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> tm.vec2(i <span class="op">/</span> n <span class="op">-</span> <span class="dv">1</span>, j <span class="op">/</span> n <span class="op">-</span> <span class="fl">0.5</span>) <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> z.norm() <span class="op">&lt;</span> <span class="dv">20</span> <span class="kw">and</span> iterations <span class="op">&lt;</span> <span class="dv">50</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> complex_square(z) <span class="op">+</span> c</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            pixels[i, j] <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> iterations <span class="op">*</span> <span class="fl">0.02</span></span></code></pre></div>
<p>This function, as you might notice, is using a <code class="verbatim">for</code> loop (a big no-no in python, usually)
to compute the sequence of complex numbers. There is a lot to unpack here, so brace
yourselves.</p>
<p>First, let’s start with the function logic itself: it takes a float parameter, <code class="verbatim">t</code>, and
for each element of the <code class="verbatim">pixels</code> field defines the constant <code class="verbatim">c</code> that will define that
particular Julia set (with some fancyness such as using the sine and cosine which,
again, are Taichi functions); then defines the initial complex number <code class="verbatim">z</code> of the sequence,
and goes on to compute the sequence, check if it diverges and update pixels using the
number of iterations the sequence endured without diverging (up to 50). A value of <span class="math inline"><em>z</em></span>
taking up 50 iterations without diverging (thus pertaining to the Julia set) will appear
as completely black, a value of <span class="math inline"><em>z</em></span> diverging in the zeroth iteration will be
completely white; anything in between will be some sade of gray.</p>
<p>You might notice the use of <code class="verbatim">tm.vec2</code> again: as said, this is a Taichi constructor
(function) for a struct with 2 fields, and therefore can only be used inside a
<em>kernel</em>. Which brings us to the meaty part: the decorator <code class="verbatim">@ti.kernel</code> itself. Taichi
kernels are the entry points to the <em>real</em> (compiled) Taichi, and they <strong>must</strong> follow two
important rules:</p>
<ul>
<li>Kernels have to be type hinted (both their arguments and their return
type).</li>
<li>Kernels cannot be nested.</li>
</ul>
<p>Since they are the entry points, you can call them anywhere in the python program
(unlike functions which can <strong>only</strong> be called from inside kernels). More importantly,
notice how the <code class="verbatim">for</code> loop iterates over <code class="verbatim">i, j</code> like it was a list of tuples: this is a key
aspect of using Taichi <code class="verbatim">field=s and of Taichi kernels; kernels /automatically parallelize
their outermost scope loop/ and by using =for i, j in myfield:</code>, you are telling Taichi
“the indices i and j of my field can be computed independently”, which makes Taichi
parallelize over both of them. This is really powerful.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>gui <span class="op">=</span> ti.GUI(<span class="st">&quot;Julia Set&quot;</span>, res<span class="op">=</span>(n <span class="op">*</span> <span class="dv">2</span>, n))</span></code></pre></div>
<p>This part is simple, but also marvelous: just call <code class="verbatim">ti.GUI</code> and a window with the
specified resolution is created for you. I find this very convenient because, while you
can of course create animations with matplotlib without much complication, it can get
tedious pretty fast; whereas using Taichi’s graphical capabilities is immediate.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>τ <span class="op">=</span> <span class="fl">6.28318530718</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>max_iter <span class="op">=</span> <span class="dv">1_000_000</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    paint(i <span class="op">*</span> τ<span class="op">/</span>(n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    gui.set_image(pixels)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    gui.show()</span></code></pre></div>
<p>Iterate a million times over the pixel data structure. That is a million Julia sets
being computed on your GPU, with no need to do anything special (other than coding using
<code class="verbatim">for</code> loops in python, finally), and it does so in a breeze.</p>
<p>As for the results, there’s a nice gif:</p>
<div class="CENTER">
<figure>
<img src="https://raw.githubusercontent.com/a-berg/learning_taichi/main/results/julia/video.gif" title="julia" alt="Julia set for c in 0.7885\exp(a i)." />
<figcaption aria-hidden="true">Julia set for <span class="math inline"><em>c</em></span> in <span class="math inline">0.7885exp (<em>a</em><em>i</em>)</span>.</figcaption>
</figure>
</div>
<p>The gif can be easily generated adding a couple (or maybe 4) lines to our code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>gui <span class="op">=</span> ti.GUI(<span class="st">&quot;Julia Set&quot;</span>, res<span class="op">=</span>(n <span class="op">*</span> <span class="dv">2</span>, n))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>video_manager <span class="op">=</span> ti.tools.VideoManager(</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    output_dir<span class="op">=</span><span class="st">&quot;./results/julia/&quot;</span>, framerate<span class="op">=</span><span class="dv">24</span>, automatic_build<span class="op">=</span><span class="va">False</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    video_manager.write_frame(pixels.to_numpy())</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>video_manager.make_video(gif<span class="op">=</span><span class="va">True</span>, mp4<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<h2 id="the-gray-scott-equations">The Gray-Scott equations</h2>
<p>Let’s now solve a more interesting problem: the Gray-Scott model of reaction-diffusion
systems. Reaction-diffusion systems are systems in which two (or more) chemical
reactives are allowed to flow through a medium at the same time as they react. They are
important for describing the occurence of natural patterns in animals. The equations
are:</p>
<p><span class="math display">$$
\begin{aligned}
    \partial{u}{t} &amp;= r_u\Delta u - uv^2 + f(1-u) \\
    \partial{v}{t} &amp;= r_v\Delta v + uv^2 - (f + k) v.
\end{aligned}
$$</span></p>
<p>You might notice the term <span class="math inline"><em>u</em><em>v</em><sup>2</sup></span>, which seems somewhat arbitrary. It is not: it
corresponds to the chemical equation <span class="math inline"><em>U</em> + 2<em>V</em> → 3<em>U</em></span> between the chemicals. As for the
rest of the equation: <span class="math inline"><em>u</em></span> and <span class="math inline"><em>v</em></span> are the concentrations of the reactives, <span class="math inline"><em>f</em></span> and
<span class="math inline"><em>k</em></span> are the <em>feed</em> and <em>kill</em> rate (the rate at which U is introduced into the system, and
V is transformed into a third, inert, component – effectively disappearing), r<sub>i</sub> are the
diffusivity parameters (how easily each reactant spreads through the medium), and we of
course have the laplacian <span class="math inline"><em>Δ</em></span> of each of the concentrations which causes the diffusion
of chemicals.</p>
<p>In this case, we are going to solve them using Taichi.</p>
<h3 id="original-numpy-code">Original numpy code</h3>
<p>Our starting point will be <a href="https://github.com/a-berg/learning_taichi/blob/main/src/gray_scott.py">this</a> old code of mine written entirely using <code class="verbatim">numpy</code>
to see how it evolves.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># gray_scott_np.py</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evolve(domain):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    domain_ <span class="op">=</span> np.pad(domain, ((<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">1</span>)), <span class="st">&quot;wrap&quot;</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> domain[<span class="dv">0</span>, :, :]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> domain[<span class="dv">1</span>, :, :]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> u <span class="op">*</span> v <span class="op">*</span> v</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    laplacian <span class="op">=</span> (</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="fl">0.25</span> <span class="op">*</span> domain_[:, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>, :<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> <span class="fl">0.25</span> <span class="op">*</span> domain_[:, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>:]</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> <span class="fl">0.25</span> <span class="op">*</span> domain_[:, :<span class="op">-</span><span class="dv">2</span>, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> <span class="fl">0.25</span> <span class="op">*</span> domain_[:, <span class="dv">2</span>:, <span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> domain</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    du <span class="op">=</span> τ <span class="op">*</span> <span class="fl">1.0</span> <span class="op">*</span> laplacian[<span class="dv">0</span>, :, :] <span class="op">-</span> r <span class="op">+</span> γ <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> u)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    dv <span class="op">=</span> τ <span class="op">*</span> <span class="fl">0.5</span> <span class="op">*</span> laplacian[<span class="dv">1</span>, :, :] <span class="op">+</span> r <span class="op">-</span> (γ <span class="op">+</span> k) <span class="op">*</span> v</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> domain <span class="op">+</span> np.stack((du, dv), <span class="dv">0</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> center_square(M, l<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    _, n, m <span class="op">=</span> M.shape</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    n <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    m <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">slice</span>(n <span class="op">-</span> l, n <span class="op">+</span> l), <span class="bu">slice</span>(m <span class="op">-</span> l, m <span class="op">+</span> l)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>τ <span class="op">=</span> <span class="fl">0.8388</span>  <span class="co"># can't quite remember why this was needed.</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>γ, k <span class="op">=</span> <span class="fl">0.024</span>, <span class="fl">0.055</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>resol <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> np.zeros((<span class="dv">2</span>, resol, resol))</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>domain[<span class="dv">0</span>, :, :] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>idx1, idx2 <span class="op">=</span> center_square(domain, <span class="dv">10</span>)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>domain[<span class="dv">1</span>, idx1, idx2] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10000</span>):</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    domain <span class="op">=</span> evolve(domain)</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">9</span>))</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>plt.imshow(domain[<span class="dv">1</span>])</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span></code></pre></div>
<h3 id="porting-to-taichi">Porting to Taichi</h3>
<p>As with the Julia code, import taichi and initialize on the GPU. I will also define the
resolution of the system (a small change: instead of using <code class="verbatim">resol</code> and defining a square
domain, I will now use width and height in case I want to use rectangular domains).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> taichi <span class="im">as</span> ti</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> taichi.math <span class="im">as</span> tm</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>ti.init(arch<span class="op">=</span>ti.gpu)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># resolution of the problem</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>W, H <span class="op">=</span> <span class="dv">256</span>, <span class="dv">256</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># for initialization purposes</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>np_grid <span class="op">=</span> np.zeros((W, H, <span class="dv">2</span>), dtype<span class="op">=</span>np.float32)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>np_grid[:, :, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># Reactant H = 1.0 in all domain initially.</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co"># square with reactant V = 1.0 in the middle of the domain</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>np_grid[(W <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">10</span>) : (W <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">10</span>), (H <span class="op">//</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">10</span>) : (H <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">10</span>), <span class="dv">1</span>] <span class="op">=</span> <span class="fl">1.0</span></span></code></pre></div>
<p>There is a <code class="verbatim">np_grid</code> array being defined. In fact, this is the only thing we need numpy
for now: initialization. Note that I could just use a kernel to do exactly the same,
however, I prefer to demonstrate the ability of Taichi of being initialized using numpy
arrays.</p>
<p>I need to define the problem domain as a Taichi <code class="verbatim">field</code>. Since there are 2 components for
each point in the field, the construct <code class="verbatim">Vector</code> is useful here (even if this is not a
truly vectorial magnitude). Taichi fields support scalar fields, vector fields, matrix
fields and struct fields.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> ti.Vector.field(n<span class="op">=</span><span class="dv">2</span>, dtype<span class="op">=</span>ti.f32, shape<span class="op">=</span>(W, H))</span></code></pre></div>
<p>When computing Julia sets the problem was embarrassingly paralel and we needed to do
nothing special to solve it because each point’s sequence was completely independent of
each other. However, because we are solving a PDE here, this problem has a temporal
dependence and we can’t update the field as we compute the next time step, or else we
would spoil the computations of other points that will mix the future and the present
state of the system. Instead, we define a secondary <code class="verbatim">Vector</code> field that will hold the
“future” state of the system as we integrate one state, then update the domain by
copying this field into the other.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># auxiliary field for PDE solving</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>future <span class="op">=</span> ti.Vector.field(n<span class="op">=</span><span class="dv">2</span>, dtype<span class="op">=</span>ti.f32, shape<span class="op">=</span>(W, H))</span></code></pre></div>
<p>Also, because we are dealing with fields that are not simply scalars, I will define
another auxiliary field that we will use for plotting. Essentially, it will map vectors
to scalars that will be plotted by Taichi’s GUI as a grayscale raster. If we wanted
colors, we should define it as another <code class="verbatim">Vector</code> field (4d for RGB+alpha).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># used for rendering</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>pixels <span class="op">=</span> ti.field(dtype<span class="op">=</span>ti.f32, shape<span class="op">=</span>(W, H))</span></code></pre></div>
<p>Now, let’s define the constants of the problem. I have changed them wrt the numpy code,
as the system is very sensitive to these constants, and they are very
computation-dependant, i.e. if this code runs quicker then the relationships between
these variables vary and the previous values give a completely different behaviour.
It would require extra work to make the computation robust.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define constants</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>r_u: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.250</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>r_v: <span class="bu">float</span> <span class="op">=</span> r_u <span class="op">/</span> <span class="dv">2</span>  <span class="co"># 0.080</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>feed: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.040</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>kill: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.062</span></span></code></pre></div>
<p>I have decided to define the laplacian as a Taichi function to make code more readable.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ti.func</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> laplacian(i: <span class="bu">int</span>, j: <span class="bu">int</span>):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Compute the laplacian of a point identified by i and j.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">    This Taichi function simply computes the discrete laplacian over a regular grid by</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">    using finite differences.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">    i : int</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">        reference to the first index of the point in the grid.</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">    j : int</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">        reference to the second intex of the point in the grid</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        domain[i <span class="op">+</span> <span class="dv">1</span>, j]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> domain[i, j <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> domain[i <span class="op">-</span> <span class="dv">1</span>, j]</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> domain[i, j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> domain[i, j] <span class="op">*</span> <span class="fl">4.0</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p>Now the meaty part: kernels. In the <code class="verbatim">numpy</code> version of the code, we used a function named
<code class="verbatim">evolve</code> to solve the equations; this function is now (unurprisingly) a Taichi
kernel. Additionally, another kernel was defined for rendering, i.e.: transforming
values of our <code class="verbatim">domain</code> into colors (or in this simple case, grayscale sclars).</p>
<p>Let’s do first the <code class="verbatim">render</code> one:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ti.kernel</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> render():</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Differently to a scalar field, vector fields need to be processed a bit for them</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">    to be paintable.&quot;&quot;&quot;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, j <span class="kw">in</span> domain:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># paint just the V concentration.</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        pixels[i, j] <span class="op">=</span> domain[i, j][<span class="dv">1</span>]</span></code></pre></div>
<p>which is very simple as you can see. Nevertheless, making it a bit more sphisticated in
order to use full RGB colors is easy, if verbose.</p>
<p>For the <code class="verbatim">evolve</code> kernel, the code is really similar to the previous version: the main
changes are that it no longer has an argument, neither does it return anything, and
there is a couple for loops: one to solve the equation and one to update the <code class="verbatim">domain</code>
for the next timestep.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">@ti.kernel</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evolve():</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Integrate one timestep of the discretized Gray-Scott equation.</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Define a Taichi kernel to compute the next state of the system. Uses Explicit Euler</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">    to integrate.</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, j <span class="kw">in</span> domain:</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        uv <span class="op">=</span> domain[i, j]</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        reaction <span class="op">=</span> uv[<span class="dv">0</span>] <span class="op">*</span> uv[<span class="dv">1</span>] <span class="op">*</span> uv[<span class="dv">1</span>]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        Δ <span class="op">=</span> laplacian(i, j)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        du <span class="op">=</span> r_u <span class="op">*</span> Δ[<span class="dv">0</span>] <span class="op">-</span> reaction <span class="op">+</span> feed <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> uv[<span class="dv">0</span>])</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        dv <span class="op">=</span> r_v <span class="op">*</span> Δ[<span class="dv">1</span>] <span class="op">+</span> reaction <span class="op">-</span> (feed <span class="op">+</span> kill) <span class="op">*</span> uv[<span class="dv">1</span>]</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># instead of returning, update in place (returning would get us outside</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># of the GPU)</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        uv_1 <span class="op">=</span> uv <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> tm.vec2(du, dv)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        future[i, j] <span class="op">=</span> uv_1</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> I <span class="kw">in</span> ti.grouped(domain):</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        domain[I] <span class="op">=</span> future[I]</span></code></pre></div>
<p>The code is not a 1:1 translation of course, but it is very similar. A new concept here:
<code class="verbatim">ti.grouped</code>. It simply allows your code to be less verbose by grouping all indices into a
single object (that implements operators such as sum or integer division). Imagine
having a 4d field: instead of using <code class="verbatim">my_array[i,j,k,l] = ...</code> you could write <code class="verbatim">my_array[i]
= ...</code> It’s purely syntactic sugar.</p>
<p>Very little remains: just write a <code class="verbatim">main()</code> function to run the simulation and manage the
GUI. You will notice the <code class="verbatim">substeps</code> variable. This is a trick I got from this <a href="https://docs.taichi-lang.org/blog/accelerate-python-code-100x">blog post</a> by
the creator of Taichi which also solves these equations; I think it accelerates the code
by evolving the system several timesteps at before painting.</p>
<blockquote>
<p>Note: at first I was convinced of it, but then I discovered that my code was going slow
not because of the lack of this trick but because generating the GIF slows the process
overall, so now I am not so sure.</p>
</blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    gui <span class="op">=</span> ti.GUI(<span class="st">&quot;Gray Scott&quot;</span>, res<span class="op">=</span>(W, H))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    substeps: <span class="bu">int</span> <span class="op">=</span> <span class="dv">60</span>  <span class="co"># 1</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    domain.from_numpy(np_grid)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    result_dir <span class="op">=</span> <span class="st">&quot;./results/reaction_diffusion/&quot;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># VideoManager let's me create gifs easily.</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    video_manager <span class="op">=</span> ti.tools.VideoManager(output_dir<span class="op">=</span>result_dir, framerate<span class="op">=</span><span class="dv">24</span>, automatic_build<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">not</span> gui.get_event(ti.GUI.ESCAPE, ti.GUI.EXIT):</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If we compute each time we render, the system evolves very slowly.</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># By evolving the equation 60 times before rendering, we accelerate the real</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># time evolution.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(substeps):</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            evolve()</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        render()</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        gui.set_image(pixels)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        gui.show()</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        video_manager.write_frame(pixels.to_numpy())</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    video_manager.make_video(gif<span class="op">=</span><span class="va">False</span>)  <span class="co"># output as mp4 that will be converted to gif later</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="co"># wrapping thing into `if __name__==&quot;__main__&quot;` prevents the function from being</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="co"># executed if we call `ti run` (my preferred method to run taichi code) in the command</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="co"># line, because that way this file is no longer &quot;__main__&quot;.</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>main()</span></code></pre></div>
<p>The results can be seen here:</p>
<div class="CENTER">
<figure>
<img src="https://raw.githubusercontent.com/a-berg/learning_taichi/main/results/reaction_diffusion/video.gif" title="gray_scott" alt="Reaction diffusion partial differential equation." />
<figcaption aria-hidden="true">Reaction diffusion partial differential equation.</figcaption>
</figure>
</div>
<h3 id="improvements">Improvements</h3>
<p>The code could be improved in many ways (e.g. use a better integrator), although I want
to focus in refactoring the code using Taichi’s OOP capabilities; and also add a color
palette to the plot. Also, I will be using a single field (with an extra dimension) like
Yuanming does in his post for the management of the two temporal steps we need in the
code; and do a small change to the GUI usage (mainly, use <code class="verbatim">canvas</code>).</p>
<p>In order to not clutter this blog post <em>even more</em>, I’m going to just link <a href="https://github.com/a-berg/learning_taichi">the github repo</a>
where you can see the final version.</p>
<h2 id="concluding-remarks">Concluding remarks</h2>
<p>The Taichi language is, at first, a bit hard to get used to (years of programming “the
numpy way” created sticky habits), but often you understand a couple concepts (namely
fields and kernels) and get used to writing <code class="verbatim">for</code> loops again, you quickly start doing
more and more.</p>
<p>I, however, expected the switch to be smoother; I ended up spending quite a few hours on
this (although most of the time was changing/perfecting small things). But the language
is kind-of addictive in the sense that it feels like magic: code that previously ran at
30 FPS now is blazing fast and you end up wanting to try out more and more things; more
simulation code, and maybe explore the autodiff capabilities writing some neural network
code.</p>
<p>That said, the overall experience is that you get <strong>a lot</strong> in terms of computing power for
very little hassle; however, these code snippets are fairly simple. I’m very interested
now in how this Taichi code would scale to larger, complex projects and how easy would it
be to manage said complexity (which is what programming really is all about).</p>
<p>Finally, my personal opinion: I had fun coding (very important!), the language makes me
want to try new things, test and write low-level algorithms by myself (that otherwise
would be lazy to do), and fits into Python very well. It seems like a nice tool to have
and I will definetively have it in my tech radar.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
